# properties from pcfcodegen_en.properties
Java.Web.PCFVerification.ActionWidget.ArgInitialValueHasNoEffect = Specifying "argInitialValue" has no effect when "argType" is not set
Java.Web.PCFVerification.ActionWidget.ArgLabelHasNoEffect = Specifying "argLabel" has no effect when "argType" is not set
Java.Web.PCFVerification.ActionWidget.ArgOptionLabelHasNoEffect = Specifying "argOptionLabel" has no effect when "argRange" is not set
Java.Web.PCFVerification.ActionWidget.ArgRangeHasNoEffect = Specifying "argRange" has no effect when "argType" is not set
Java.Web.PCFVerification.ActionWidget.ArgValueAlreadyDefined = A parent scope already defines a symbol named "ArgValue," which conflicts with the symbol automatically created by setting the "argType" attribute
Java.Web.PCFVerification.ActionWidget.ArgWidthHasNoEffect = Specifying "argWidth" has no effect when "argRange" is not set
Java.Web.PCFVerification.ActionWidget.CannotHaveBothActionAndMenu = Not allowed to specify both "action" attribute and child menu item(s) at the same time.
Java.Web.PCFVerification.ActionWidget.IconHasNoEffect = Specifying "icon" has no effect when "performActionOnArgChange" is set
Java.Web.PCFVerification.ActionWidget.LabelHasNoEffect = Specifying "label" has no effect when "performActionOnArgChange" is set
Java.Web.PCFVerification.ActionWidget.PerformActionOnArgChangeHasNoEffect = Specifying "performActionOnArgChange" has no effect when "argType" is not set
Java.Web.PCFVerification.ActionWidget.UnsupportedArgType = has an unsupported "argType" '{0}', which resolves into '{1}'
Java.Web.PCFVerification.AutocompleteRangeValueWidget.CannotBeSingleSelect = AutocompleteListInput cannot be used as a single-selection input.
Java.Web.PCFVerification.AutocompleteRangeValueWidget.IllegalOptionLabel = optionLabel attribute is not permitted on autocomplete multi-select inputs.
Java.Web.PCFVerification.AutocompleteRangeValueWidget.IllegalValue = Autocomplete can only be used when the value is an array of Strings.
Java.Web.PCFVerification.Base.AttributeMustBeOneOf = Attribute '{0}' must be one of '{1}'.
Java.Web.PCFVerification.Base.DoesNotExist = '{0}' does not exist.
Java.Web.PCFVerification.Base.DuplicateId = Id {0} is already used by file {1}.
Java.Web.PCFVerification.Base.MultipleIncludes = '{0}' is included in multiple location groups({1}) which is not allowed. All but one of these references needs to be removed.
Java.Web.PCFVerification.Base.EmptyId = has an empty ID.
Java.Web.PCFVerification.Base.ErrorOnAttribute = Invalid '{0}' expression\:
Java.Web.PCFVerification.Base.IllegalExpression = has an invalid '{0}' expression ({1})'.
Java.Web.PCFVerification.Base.IllegalId = Invalid id\="{0}"\: must start with a letter or "_" and include only letters, digits, or "_".
Java.Web.PCFVerification.Base.IllegalTopLevelId = Invalid id\="{0}"\: id for the first element in the file must not conflict with any Gosu keywords, must start with a letter or "_" and include only letters, digits, or "_".
Java.Web.PCFVerification.Base.IllegalIdConflict = has an invalid id '{0}' that conflicts with an auto-generated id. Please choose a different one."
Java.Web.PCFVerification.Base.IllegalIdSuffix = has an invalid id\="{0}"\: elements of type "{1}" must have an id with the suffix "{2}".
Java.Web.PCFVerification.Base.IllegalJavaConstructor = Static Java constructor '{0}' specifies an invalid location '{1}'.
Java.Web.PCFVerification.Base.IllegalLocationConstructor = Invalid java LocationConstructor \: '{0}'. possible matches are '{1}'.
Java.Web.PCFVerification.Base.IllegalTopLevelElement = The element {0} is not allowed as the top-level element in a PCF file
Java.Web.PCFVerification.Base.IllegalXXX = has an invalid '{0}' ({1})'.
Java.Web.PCFVerification.Base.InvalidNumberFormat = Invalid number format\: '{0}'.
Java.Web.PCFVerification.Base.SingleTopLevelElement = PCF files can only contain a single top-level element
Java.Web.PCFVerification.Base.TypeNameIsNotAvailable = Type name is not available
Java.Web.PCFVerification.Base.UnknownError = An unknown error occurred\: {0}.
Java.Web.PCFVerification.Base.WarningOnAttribute = Warning on '{0}' attribute\:
Java.Web.PCFVerification.CellWidget.CannotBeEditable = Cell in a non-editable RowIterator ({0}) cannot be editable.
Java.Web.PCFVerification.CellWidget.CannotBeEditableInColumnFooter = Cell in a column footer cannot be editable.
Java.Web.PCFVerification.CellWidget.CannotBeEditableInColumnHeader = Cell in a column header cannot be editable.
Java.Web.PCFVerification.CellWidget.CategoricalChartMustHaveXAxis = categorical chart type must have a categorical x-axis.
Java.Web.PCFVerification.CellWidget.ChartMustSpecifyOneDataSeries = ChartPanel must specify at least one DataSeries.
Java.Web.PCFVerification.CellWidget.CellContainingDVWithLVInput = A detail view in a cell cannot contain a List View Input.
Java.Web.PCFVerification.CellWidget.CellContainingDVWithMultipleEditableInputs = This detail view has a cell that may contain multiple editable inputs, but a detail view with a cell that contains multiple editable inputs is not supported.  If such a configuration is needed, convert the edit to go to a Popup.
Java.Web.PCFVerification.CellWidget.CellIsNotAllowed = Elements of type 'Cell' are no longer allowed.  They should be replaced with explicit Cell types like TextCell or DateCell.
Java.Web.PCFVerification.CellWidget.ColspanMixedWithFooter = Colspan cannot be mixed with a cell that has a footer.
Java.Web.PCFVerification.CellWidget.ContinuousChartMustHaveXAxis = continuous chart type must not have a categorical x-axis.
Java.Web.PCFVerification.CellWidget.DataSeriesInCatChartMustHaveCatLabel = data series in a categorical chart must specify categoryLabel.
Java.Web.PCFVerification.CellWidget.DataSeriesInCatChartMustNotHaveXValue = data series in a categorical chart cannot specify an xValue.
Java.Web.PCFVerification.CellWidget.DataSeriesInContChartMustNotHaveCatLabel = data series in a continuous chart cannot specify categoryLabel.
Java.Web.PCFVerification.CellWidget.DataSeriesInContChartMustHaveXValue = xValue is required if not provided.
Java.Web.PCFVerification.CellWidget.DataSeriesInDistribMustSpecifySingleValue = data series in a distribution-based chart may not specify a single value.
Java.Web.PCFVerification.CellWidget.DataSeriesInDistribMustSpecifyStatValues = data series in a distribution-based chart must specify all of mean, median, min, max, firstQuartile, and thirdQuartile.
Java.Web.PCFVerification.CellWidget.DomainAxisMustBeSpecified = DomainAxis and RangeAxis must be specified.
Java.Web.PCFVerification.CellWidget.FormatCellWidgetConfig.ActionNotAllowedOnChildren = The Inputs inside a FormatCell are not allowed to have an action set.  Try using LinkCell instead.
Java.Web.PCFVerification.CellWidget.FormatCellWidgetConfig.WrongTypeOfChildren = Wrong type of widget under FormatCell. Only TextInput, ContentInput and NoteBodyInput are allowed as the children of FormatCell.
Java.Web.PCFVerification.CellWidget.HasCheckBoxCannotBeInRenderAsSmartHeader = "hasCheckBox" is not allowed when the Cell is in a Row with "renderAsSmartHeader" set to true.
Java.Web.PCFVerification.CellWidget.HasCheckBoxIllegal = "hasCheckBox" is only allowed when the Cell is used inside an Iterator.
Java.Web.PCFVerification.CellWidget.HasCheckBoxIllegalWhenEditable = "hasCheckBox" is only allowed when the Cell is not editable.
Java.Web.PCFVerification.CellWidget.HasColumnFilterWithSmartHeader = A Cell that specifies hasColumnFilter will generate an extraneous header row in the UI when combined with a Row that uses renderAsSmartHeader
Java.Web.PCFVerification.CellWidget.IdReservedByExtJS = Ids of the form c0, c1 and so on are reserved for use by the client side toolkit and may cause display issues if used as the id of a cell
Java.Web.PCFVerification.CellWidget.IllegalCellTypeInExplicitHeader = {0} is not allowed in a column header. Use a TextCell instead.
Java.Web.PCFVerification.CellWidget.IllegalColspan = has a "colspan" less than 1.
Java.Web.PCFVerification.CellWidget.IllegalColumnFooter = has child ColumnFooter while itself is a column footer.
Java.Web.PCFVerification.CellWidget.IllegalExplicitFooterInRowset = defines an explicit footer cell from within a RowSet.
Java.Web.PCFVerification.CellWidget.IllegalFooterLabel = has both a "footerLabel" and a "footerSumValue".
Java.Web.PCFVerification.CellWidget.IllegalFooterSumOrLabel = cannot have footerSumValue or footerLabel, when a child ColumnFooter exists.
Java.Web.PCFVerification.CellWidget.IllegalFooterSumOrLabelWithColumnFooter = has a "footerSumValue" or "footerLabel" while itself is a column footer.
Java.Web.PCFVerification.CellWidget.IllegalImplicitFooter = creates an implicit footer cell from within a RowSet.  Consider creating an explicit footer row.
Java.Web.PCFVerification.CellWidget.IllegalImplicitHeader = creates an implicit header cell from within a RowSet.  Consider creating an explicit header row.
Java.Web.PCFVerification.CellWidget.IllegalLabelOrIconWithColumnFooter = has label or header icon while itself is a column footer.
Java.Web.PCFVerification.CellWidget.IllegalNestedIteratorGrouped = cell in nested iterator cannot have grouped definition.
Java.Web.PCFVerification.CellWidget.IllegalSortBy = has "sortBy" but has no header cell.
Java.Web.PCFVerification.CellWidget.IllegalValidationLabel = "validationLabel" is not allowed when "label" is set.
Java.Web.PCFVerification.CellWidget.IllegalValueWithIcon = Cell has an "icon", but its "value" is not boolean.  It is '{0}'.
Java.Web.PCFVerification.CellWidget.IllegalWidth = '{0}' is not a number and will be ignored.
Java.Web.PCFVerification.CellWidget.InvalidAttributeUnderModalCell = This attribute is not applicable on a cell under a modal cell context.
Java.Web.PCFVerification.CellWidget.InvalidLabel = Cell header label cannot be determined using the iterated element; the symbols '{0}' are not available here.
Java.Web.PCFVerification.CellWidget.InvalidTooltip = Cell header tooltip cannot be determined using the iterated element; the symbols '{0}' are not available here.
Java.Web.PCFVerification.CellWidget.InvalidVisibility = Cell visibility cannot be determined using the iterated element; the symbols '{0}' are not available here.  Consider using the valueVisible attribute instead.  Consider ModalCell and ModalCellRef for configuring different grid cells in the same column for different rows.
Java.Web.PCFVerification.CellWidget.PieMayNotSpecifyDomainAxis = pie charts may not specify a domain axis.
Java.Web.PCFVerification.CellWidget.PieMayNotSpecifyRangeAxis = pie charts may not specify a range axis.
Java.Web.PCFVerification.CellWidget.PieMayNotSpecifySecondaryAxis = pie charts may not specify a secondary axis.
Java.Web.PCFVerification.CellWidget.SecondaryAxisMayNotBePie = secondary axis cannot be type 'Pie'.
Java.Web.PCFVerification.CellWidget.TimeSeriesMustHaveXAxis = time series chart must have a date-type x-axis.
Java.Web.PCFVerification.CellWidget.TooltipWithNoHeader = Cell specifies "toolTip", but has no header to put the toolTip on.
Java.Web.PCFVerification.CheckboxGroupRangeValueWidget.IllegalValue = has a value type that does not support multi-select '{0}'. Use range radio widget for single select instead.
Java.Web.PCFVerification.CheckedValuesActionListener.ActionRequired = At least one of checkedRowAction, allCheckedRowsAction or pickValue must be specified.
Java.Web.PCFVerification.CheckedValuesActionListener.OnlyOneAllowed = Only one of checkedRowAction, allCheckedRowsAction or pickValue can be specified.
Java.Web.PCFVerification.CheckedValuesActionWidget.CheckedRowActionShouldUseCheckedValue = checkedRowAction should be converted to use CheckedValue instead of the element name\: '{0}'.
Java.Web.PCFVerification.CheckedValuesToolbarButtonWidget.CheckedValuesNeedsUpgrade = This CheckedValues button needs to have its iterator upgraded, config '{0}'.
Java.Web.PCFVerification.CheckedValuesToolbarButtonWidget.CheckedValuesNeedsUpgradeWithLV = This CheckedValues button needs to have its iterator upgraded, config '{0}'.  The iterator is in a panel ref LV with id '{1}'
Java.Web.PCFVerification.CheckedValuesToolbarButtonWidget.IteratorsExposeDifferentNames = Enclosing iterators expose different element names '{0}', '{1}'.
Java.Web.PCFVerification.CheckedValuesToolbarButtonWidget.IteratorsExposeDifferentTypes = Enclosing iterators expose different element types '{0}', '{1}'.
Java.Web.PCFVerification.CheckedValuesToolbarButtonWidget.NoIterator = Could not find iterator '{0}' for any referencing types.
Java.Web.PCFVerification.ChoiceWidget.MustHaveOneInput = must include at least one input to contain the radio button.
Java.Web.PCFVerification.ConfirmPasswordInputWidget.OldPasswordLabelRequired = Attribute 'oldPasswordLabel' is required when 'requireOldPassword' is true.
Java.Web.PCFVerification.Constructor.BadParameters = Invalid parameter list in LocationEntryPoint signature '{0}'.
Java.Web.PCFVerification.Constructor.EmptyParameterName = Parameter name should not be null or empty.
Java.Web.PCFVerification.Constructor.InvalidArgumentType = The type specified for the '{0}' argument should be '{1}' but is '{2}'.
Java.Web.PCFVerification.Constructor.InvalidParameterName = The parameter name '{0}' must match one of the variables on the location.
Java.Web.PCFVerification.Constructor.MissingTypeName = LocationEntryPoint signature '{0}' contains an argument with no type specified
Java.Web.PCFVerification.Constructor.NoParameters = LocationEntryPoint signature '{0}' must have a parameter list, or just () if it has no parameters.
Java.Web.PCFVerification.ContactSubtypeAccessProfileNode.DuplicatePermission = Duplicated permission typecode '{0}' found in the permission config '{1}' for entity '{2}'.
Java.Web.PCFVerification.ContactTagAccessProfileNode.DuplicatePermission = Duplicated permission typecode '{0}' found in the permission config '{1}' for tag '{2}'.
Java.Web.PCFVerification.CurrencyValueWidget.DoesNotSupportRequestValidation = does not support "requestValidationExpression".
Java.Web.PCFVerification.CurrencyValueWidget.ExchangeRateDeprecated = defines deprecated "exchangeRate" attribute. Instead you need to set exchange rate into the backing model and let the model handle currency conversion calculation.
Java.Web.PCFVerification.CurrencyValueWidget.ExchangeRateOnlySupportedForMoneyFacade = "exchangeRate" attribute is only supported when the value type is '{0}', but got '{1}'
Java.Web.PCFVerification.CurrencyValueWidget.ValueNotAMoneyType = has a "value" expression that is not of type '{0}'.
Java.Web.PCFVerification.DataSeriesElement.DataValuesTypeMustBeList = dataValues type must be an array, List, or Query.
Java.Web.PCFVerification.DataSeriesElement.MustHaveNonEmptyLabel = DataSeriesElement must specify a non-empty label
Java.Web.PCFVerification.Destination.CannotFindVariable = requires a variable named '{0}', but no such variable has been defined.
Java.Web.PCFVerification.DetailViewPanel.MustHaveInputColumnOrTableLayout = must have either InputColumn or Table Layout as a child element.
Java.Web.PCFVerification.DetailViewPanel.TableLayoutNotAllowedWithInputColumns = A DetailViewPanel cannot contain InputColumns, InputHeaderSections or FooterHeaderSections if it specifies a Layout of type "table"
Java.Web.PCFVerification.DetailViewPanel.MustBeInsideInputColumn = Inputs are not allowed outside of an InputColumn unless the DetailViewPanel has a Layout element.
Java.Web.PCFVerification.DualAxisDataSeriesElement.CategoricalSecondaryAxisNonCategoricalChart = Categorical secondary axis cannot be used on a non-categorical chart.
Java.Web.PCFVerification.DualAxisDataSeriesElement.NonCategoricalSecondaryAxisCategoricalChart = Non-categorical secondary axis cannot be used on a categorical chart.
Java.Web.PCFVerification.EditButtonsWidget.InvisibleWhenCantEdit = EditButtons will never appear on a Page where canEdit is false.
Java.Web.PCFVerification.EntryPoint.MissingLocation = Missing or bad "location" attribute.
Java.Web.PCFVerification.ExitPoint.CannotHaveBothLogoutAndPopup = cannot have both "logout" and "popup" set to true.
Java.Web.PCFVerification.ExitPoint.CannotHaveBothPopupAndPOST = cannot have "popup" set to true if "method" is POST.
Java.Web.PCFVerification.ExitPoint.CannotWidthWithoutPopup = cannot set a value for "width" or "height" unless "popup" is true.
Java.Web.PCFVerification.ExitPoint.MustHaveBothWidthAndHeight = must set a value for both "width" *and* "height", or for neither.
Java.Web.PCFVerification.ExposeElement.IllegalPosition = is not allowed to have child Expose elements when inlined within other elements.
Java.Web.PCFVerification.ExpressionRangeValueWidget.ExpectedCollectionValueType = has a value range of type '{0}', but needs an array, queryprocessor, or query type.
Java.Web.PCFVerification.ExpressionRangeValueWidget.IllegalRangeRadio = RangeRadioInput cannot be used for a multi-select widget.
Java.Web.PCFVerification.ExpressionRangeValueWidget.IllegalValueRange = has a value range of array or query of type "{0}", but expects type "{1}".
Java.Web.PCFVerification.ExpressionRangeValueWidget.MustHaveRangeValue = needs to define a valueRange expression.
Java.Web.PCFVerification.Forward.CannotDefineBothActionAndForwardConditions = is not allowed to define both an "action" and ForwardConditions.
Java.Web.PCFVerification.GosuActionListener.DrilldownDoesntPassIteratorElement = Call to drilldown() doesn't pass in Iterator element ({0}).
Java.Web.PCFVerification.GosuActionListener.DrilldownOutsideIterator = Cannot call drilldown() outside of an Iterator.
Java.Web.PCFVerification.HeaderCellValueWidget.CantShowIcon = Cannot show icon in header cell, since it is different per row.  Set showHeaderIcon to false.
Java.Web.PCFVerification.HeaderCellValueWidget.EntityWithNoDisplayNameNotSortable = Cell in a query-based LV is sortable, but has a sort value that specifies sort ordering with a path [{0}] that resolves into an entity without a display name. Entity without display name cannot be sorted.
Java.Web.PCFVerification.HeaderCellValueWidget.IllegalDatatypeForFilter = cannot filter a column with data type '{0}'.
Java.Web.PCFVerification.HeaderCellValueWidget.QueryCellNotSortable = Cell in a query-based LV is sortable, but has a sort value that does not specify sorting behavior\: {0}.
Java.Web.PCFVerification.HeaderCellValueWidget.SortValueNotInDB = Cell in a query-based LV is sortable, but has a sort value that specifies sort ordering with a path [{0}] that isn't in the database.
Java.Web.PCFVerification.HeaderCellValueWidget.SortingThrewException = Cell in a query-based LV is sortable, but threw an exception when getting the sort ordering.  Sort value\: [{0}]
Java.Web.PCFVerification.HeaderCellValueWidget.TextColumnsNotSortable = Cell in a query-based LV is sortable, but has a sort value that specifies sort ordering with a path [{0}] that resolves to a text column.  Text columns cannot be sorted in the database.
Java.Web.PCFVerification.InputGroupWidget.NotAllowedToBeNested = InputGroups cannot be nested inside other InputsGroups.
Java.Web.PCFVerification.InputGroupWidget.NotAllowedToBeNestedAcrossSections = InputGroups cannot be nested inside other InputsGroups.  This InputGroup ends up nested when included by an InputSetRef inside {0}.
Java.Web.PCFVerification.InputSectionWidget.MustBeFirstOrLast = Must be either the first widget or the last widget in '{0}'
Java.Web.PCFVerification.InputWidget.InputIsNotAllowed = Elements of type 'Input' are no longer allowed.  They should be replaced with explicit Input types like TextInput or DateInput.
Java.Web.PCFVerification.IteratorAddButtonWidget.CannotHaveConversionWithoutPick = Cannot define a "conversionExpression" if no "pickLocation" is defined.
Java.Web.PCFVerification.IteratorAddButtonWidget.InvalidCreateToAndAdd = has an invalid "toCreateAndAdd" expression\: it must return a value of type "{0}"
Java.Web.PCFVerification.IteratorAddButtonWidget.InvalidCreateToAndAddWithArray = has an invalid "toCreateAndAdd" expression\: it must return a value of type "{0}"  or "{1}[]"
Java.Web.PCFVerification.IteratorAddButtonWidget.IteratorNotNeeded = Iterator not needed when all child AddMenuItems have iterators specified.
Java.Web.PCFVerification.IteratorAddButtonWidget.MustSpecifyIterator = does not specify iterator and does not have child AddMenuItems.
Java.Web.PCFVerification.IteratorAddButtonWidget.MustSpecifyIteratorOrOnParent = does not specify iterator and parent AddButton does not specify iterator.
Java.Web.PCFVerification.IteratorSortWidget.DuplicateSortElements = Two IteratorSort elements defined with sortOrder '{0}'
Java.Web.PCFVerification.IteratorWidget.Ambiguous = Ambiguous iterator reference, found more than one child iterator in LV with id '{0}'
Java.Web.PCFVerification.IteratorWidget.AmbiguousWithMultipleOccurrences = Iterator reference is ambiguous, found multiple occurrences of the iterator '{0}', on the following lines\: {1}
Java.Web.PCFVerification.IteratorWidget.AssociatedWithAnotherToolbar = Specifies an "iterator" which is associated with another toolbar.
Java.Web.PCFVerification.IteratorWidget.AutoAddHasNoEffectIfNoToAddOrToCreateAndAdd = Specifying "autoAdd" has no effect if no "toAdd" or "toCreateAndAdd" is defined.
Java.Web.PCFVerification.IteratorWidget.CannotComputeValueComponentType = Failed to resolve entry type for value '{0}'
Java.Web.PCFVerification.IteratorWidget.CannotHaveAutoAddIfPickLocation = Cannot define "autoAdd" if a "pickLocation" is defined.
Java.Web.PCFVerification.IteratorWidget.CannotHaveConversionExpressionIfNoPickLocation = Cannot define a "conversionExpression" if no "pickLocation" is defined
Java.Web.PCFVerification.IteratorWidget.CannotHaveToAddAndToCreateAndAdd = Cannot define both "toAdd" and "toCreateAndAdd" expressions.
Java.Web.PCFVerification.IteratorWidget.CannotHaveToCreateAndAddIfPickLocation = Cannot define "toCreateAndAdd" if a "pickLocation" is defined.
Java.Web.PCFVerification.IteratorWidget.CouldNotFindIterator = Could not find iterator or lv panel with id '{0}'.
Java.Web.PCFVerification.IteratorWidget.CouldNotFindReferencedIterator = Could not find ReferencedIterator or ReferencedRowTree with widget '{0}'
Java.Web.PCFVerification.IteratorWidget.ElementNameConflictsWithRequireOrVariable = The Variable named '{0}' conflicts with the elementName attribute of the {1}
Java.Web.PCFVerification.IteratorWidget.IllegalComponentType = The specified type '{0}' is not a subtype of the component type '{1}' from the value.
Java.Web.PCFVerification.IteratorWidget.MissingIterator = Cannot reference lv {0} because it does not have a row iterator.
Java.Web.PCFVerification.IteratorWidget.MustDefineId = Must have an id when there are other Iterator widget(s) without id under '{0}'.
Java.Web.PCFVerification.IteratorWidget.NoValue = No "value" expression defined.
Java.Web.PCFVerification.IteratorWidget.QuickAddOnEnterButNoAdd=Specifies "quickAddOnEnter" but does not enable Add
Java.Web.PCFVerification.IteratorWidget.QuickAddOnEnterUnderLDP = Specifies "quickAddOnEnter" but is under a ListDetailPanel.
Java.Web.PCFVerification.IteratorWidget.QuickAddOnEnterUnderLDPAcrossSections = Specifies "quickAddOnEnter" but is under a ListDetailPanel.  The file {0} contains a ListDetailPanel that includes the section that defines this element.
Java.Web.PCFVerification.IteratorWidget.QuickAddOnEnterWithAddMultipleEntries=Specifies "quickAddOnEnter" but has "numEntriesToAdd" greater than one
Java.Web.PCFVerification.IteratorWidget.QuickAddOnEnterWithCellNavOnEnter=No need to set "cellNavOnEnter" when "quickAddOnEnter" is set
Java.Web.PCFVerification.IteratorWidget.QuickAddOnEnterWithPickLocation="quickAddOnEnter" is not supported when "pickLocation" is specified.
Java.Web.PCFVerification.IteratorWidget.QuickAddOnEnterWithSiblings = Specifies "quickAddOnEnter" but is not the only RowIterator under the ListViewPanel.
Java.Web.PCFVerification.IteratorWidget.QuickAddOnEnterWithSiblingsAcrossSections = Specifies "quickAddOnEnter" but is not the only RowIterator under the ListViewPanel.  The file {0} contains a ListViewPanel that includes the section that defines this element.
Java.Web.PCFVerification.IteratorWidget.ToAddOnlyForEntities = An iterator whose entries are not entities cannot use "toAdd".  Use "toCreateAndAdd" instead.
Java.Web.PCFVerification.IteratorWidget.ValueHasNonEmptyArrayType = "value" expression has a non-array type (type is '{0}').
Java.Web.PCFVerification.IteratorWidget.EntryTypeMismatch = Iterator entry type mismatch, expected entry type '{0}', given entry type '{1}'.
Java.Web.PCFVerification.IteratorWidget.ValueTypeMismatch = Iterator value type mismatch, required value type '{0}' , iterator value type '{1}'.
Java.Web.PCFVerification.LayoutConfig.MustHaveDetailViewAncestorThatUsesATableLayout = The LayoutConfig element can only be used on an Input or Label that resides underneath a DetailViewPanel that specifies a Layout of type "table"
Java.Web.PCFVerification.LayoutConfig.MustHaveDetailViewAncestorThatUsesATableLayoutAcrossSections = The LayoutConfig element can only be used on an Input or Label that resides underneath a DetailViewPanel that specifies a Layout of type "table".  The file {0} contains a DetailViewPanel without a "table" Layout that ultimately includes this LayoutConfig.
Java.Web.PCFVerification.LayoutElement.LayoutMustHaveDetailViewAncestor = Table layout is not allowed at [{0}], because it's nested inside another Table layout at [{1}].
Java.Web.PCFVerification.LayoutElement.NestedLayout = Table layout is not allowed at [{0}], because it's nested inside another Table layout at [{1}].
Java.Web.PCFVerification.LinkCellWidget.IdRequiredUnderRowTree = id is required for linkCell under rowTree
Java.Web.PCFVerification.LinkCellWidget.IdRequiredWhenSortByProvided = id is required for LinkCell when sortBy attribute is provided
Java.Web.PCFVerification.LinkWidget.ArgTypeNotAllowedUnderCell = "argType" is not allowed when the link is used under a Cell
Java.Web.PCFVerification.LinkWidget.MustSpecifyLabelOrIcon = must specify either a "label" or an "icon".
Java.Web.PCFVerification.ListDetailPanelWidget.IllegalSelectType = Select type for list detail panel is invalid.
Java.Web.PCFVerification.ListDetailPanelWidget.MustContainOnlyOneChildListCardViewPanel = must contain one and only child CardViewPanel but contains '{0}'.
Java.Web.PCFVerification.ListDetailPanelWidget.MustContainOnlyOneChildListViewPanel = must contain one and only one child ListViewPanel but contains '{0}'.
Java.Web.PCFVerification.ListDetailPanelWidget.MustHaveListViewBeforeCardView = must define the child ListViewPanel before the child CardViewPanel.
Java.Web.PCFVerification.ListDetailPanelWidget.NullSelectType = Select type for list detail panel is null.
Java.Web.PCFVerification.ListDetailPanelWidget.SelectionNameConflictsWithRequireOrVariable = The {0} named '{1}' conflicts with the selectionName on the containing ListDetailPanel
Java.Web.PCFVerification.ListViewWidget.IteratedFootersDoNotMatch = ListView has iterated footers that do not match.
Java.Web.PCFVerification.ListViewWidget.MoreThanOneIteratedFooter = ListView has more than 1 iterated footer defined and only one will render.  Consider removing the other footers by removing the footer related attribute from the cells.
Java.Web.PCFVerification.ListViewWidget.MoreThanOneIteratedHeader = ListView has more than 1 iterated header defined and only one will render.  Consider removing the other headers by removing the label attribute from the cells.
Java.Web.PCFVerification.ListViewWidget.MoreThanOnePagingIterator = ListView can only have at most 1 paging RowIterator.  Turn off paging by setting pageSize to zero.
Java.Web.PCFVerification.ListViewWidget.MustContainToolbarChild = must contain a Toolbar child.
Java.Web.PCFVerification.ListViewWidget.NumberOfCellsDoNotMatch = ListView contains Rows that have different numbers of Cells. There may be a misalignment of the columns.
Java.Web.PCFVerification.ListViewWidget.NumberOfCellsDoNotMatchInRowSet = ListView contains RowSet '{0}' that has different numbers of Cells. There may be a misalignment of the columns.
Java.Web.PCFVerification.Location.HandlesValidationIssueHasNoEffect = Specifying "handlesValidationIssue" has no effect when "validationParameter" is not specified.
Java.Web.PCFVerification.Location.IdDoesntMatchFileName = has an id '{0}'  that does not match file name '{1}'.
Java.Web.PCFVerification.Location.IllegalId = LocationEntryPoint ({0}) must match location ID ({1}).
Java.Web.PCFVerification.Location.IllegalLocationKey = A '{0}' with the ID '{1}' must exist for code to refer to it.
Java.Web.PCFVerification.Location.IllegalLocationKeyType = The location defined with ID '{0}' must be of type '{1}'.
Java.Web.PCFVerification.Location.IllegalTabBarExpression = tabBar expression '{0}' resolves to an element of type '{1}', but must reference a TabBar element.
Java.Web.PCFVerification.Location.IllegalTypeMismatch = Type of "pickValue" [{0}] does not match "returnType" [{1}] of "{2}".
Java.Web.PCFVerification.Location.IllegalValidationParameter = has an invalid "validationParameter". No such Variable '{0}'.
Java.Web.PCFVerification.Location.NotATopLevelObject = is not a top-level object.
Java.Web.PCFVerification.Location.ParentCycle = Cycle in parents for {0}: {1}.
Java.Web.PCFVerification.Location.PickValueDoesNotMatchReturnType = Type of "pickValue" ({0}) does not match "returnType" ({1}) of '{2}'.
Java.Web.PCFVerification.Location.PickValueNotAllowedWithoutReturnType = "pickValue" not allowed if the containing location does not has a "returnType".
Java.Web.PCFVerification.Location.SelfParent = Location {0} is its own parent.
Java.Web.PCFVerification.Location.TabBarNotFound = No TabBar exists with the id '{0}'.
Java.Web.PCFVerification.Location.WrongNumberOfArguments = Wrong number of arguments for location '{0}'.
Java.Web.PCFVerification.Location.WrongNumberOfArgumentsWithExpected = Wrong number of arguments for location.  Expected '{0}', got '{1}'.
Java.Web.PCFVerification.Location.UnableToCreateParentExpression = No parent expression was specified for Location '{0}', and no LocationEntryPoint was found on the parent LocationGroup '{1}' with a set of symbols that are available from within this Location.
Java.Web.PCFVerification.LocationRef.InvalidForm = '{0}' attribute must be of the form <location>(<arguments>).
Java.Web.PCFVerification.LocationRef.InvalidLocation = '{0}' is not a valid location
Java.Web.PCFVerification.LocationRef.Popup = '{0}' is a popup and cannot be used as the target of a LocationRef
Java.Web.PCFVerification.MenuItemWidget.IllegalSubMenuOnDemand = has subMenuOnDemand and is an immediate child item of a flattened menu. To fix this error, remove "subMenuOnDemand", move this item to a lower level in the menu, or remove "flatten" from parent menu container.
Java.Web.PCFVerification.MenuItemWidget.IllegalSubMenuOnDemandAcrossSections = has subMenuOnDemand and is an immediate child item of a flattened menu. To fix this error, remove "subMenuOnDemand", move this item to a lower level in the menu, or remove "flatten" from parent menu container.  The parent menu container is contained in {0}
Java.Web.PCFVerification.PCFElement.FailedToCallMethod = failed to call super.{0} in one of its compile methods.
Java.Web.PCFVerification.PCFElement.MissingSectionWidgetConfig = Missing section widget config, you may have added both a ref and an inline section to '{0}\:{1}' for element '{2}'.
Java.Web.PCFVerification.Page.IllegalAlwaysInEditModeWithStartInEdit = is marked 'alwaysInEditMode' but 'startInEditMode' is not marked 'true'; please specify 'startInEditMode' true.
Java.Web.PCFVerification.Page.IllegalAlwaysInEditModeWithWithNoCanEdit = is marked 'alwaysInEditMode' but has no 'canEdit' expression; please specify 'canEdit\="true"'
Java.Web.PCFVerification.Page.IllegalChildScreen = cannot have both Screen and ScreenRef as children.
Java.Web.PCFVerification.Page.IllegalStartInEditModeWithWithBadCanEdit = is marked 'startInEditMode' but has 'canEdit'\="false"
Java.Web.PCFVerification.Page.IllegalStartInEditModeWithWithNoCanEdit = is marked 'startInEditMode' but has no 'canEdit' expression; please specify 'canEdit\="true"'
Java.Web.PCFVerification.Page.IllegalCyclicParent = '{0}' belongs to a cyclical parent hierarchy.
Java.Web.PCFVerification.Page.MissingChildScreen = must have either a child Screen or a child ScreenRef.
Java.Web.PCFVerification.Page.MustHaveParentOrLocationGroup = must have a parent or be included in a LocationGroup.
Java.Web.PCFVerification.PanelIteratorWidget.PaginationOnlyWorksInPanelSetWithSingleChild = pagination only works in a PanelSet with single PanelIterator defined.
Java.Web.PCFVerification.PanelRefWidget.IllegalDefExpression = has an invalid def expression, the type '{0}' is not one of the allowed type(s) (see pcf documentation for allowed type(s)).
Java.Web.PCFVerification.PanelRefWidget.RefNotFound = No panel exists with the id '{0}'.
Java.Web.PCFVerification.PanelRefWidget.MustHaveIdOrChildDef = must specify either a definition ID or a child Def element.
Java.Web.PCFVerification.PanelRefWidget.MustHaveIdOrChildDefNotBoth = cannot specify both a definition ID and a child Def element.
Java.Web.PCFVerification.PickListener.OnPickWillNotBeExecuted = onPick expression of '{0}' will not be executed when child widget '{1}' at '{2}' is invoked.
Java.Web.PCFVerification.PickValue.UndeterminedType = Cannot determine type of pick value because element is enclosed by multiple popups with different return types\: {0}
Java.Web.PCFVerification.PickWidget.ConversionError = After converting the type '{0}' from location '{1}' with the expression '{2}' the type is '{3}' which cannot be added to an array of type '{4}'.
Java.Web.PCFVerification.PickWidget.IllegalLocationType = Location '{0}' has type '{1}' which cannot be added into an array of type '{2}'
Java.Web.PCFVerification.PickWidget.IllegalPickLocation = pickLocation attribute is invalid, it must reference a Popup.
Java.Web.PCFVerification.PickWidget.NoReturnType = Location '{0}' does not define a returnType, so it cannot be used as a pick location.
Java.Web.PCFVerification.PickWidget.IllegalReturnTypeWithConversion = The location '{0}' does not define a returnType, and '{1}' requires it to have returnType\="{2}" after passing through the conversion expression "{3}".
Java.Web.PCFVerification.PickWidget.LocationNeedsReturnType = Location '{0}' must declare a return type to be picked from by '{1}'.
Java.Web.PCFVerification.PickWidget.MustBeSimplePush = The action for a pick widget must be a simple push.
Java.Web.PCFVerification.PickWidget.TypeDoesNotMatchLocation = The value of this picker is of type '{0}' but the location '{1}'  has a returnType of '{2}' You can use a conversion expression to produce the correct value type.
Java.Web.PCFVerification.PickWidget.TypeDoesNotMatchLocationWithExpression = The value of this picker is of type '{0}' but the conversion expression returns '{1}'.
Java.Web.PCFVerification.Popup.CannotUseCurrentLocation = Cannot use 'CurrentLocation' in afterCommit.  Use 'TopLocation' instead.
Java.Web.PCFVerification.PostOnChangeElement.AmbiguousPanelRefId = Found more than on panel matching '{0}' when resolving '{1}'
Java.Web.PCFVerification.PostOnChangeElement.DuplicateTargetInReferenceWidget = Found match id in the pcf as well as ReferenceWidget for the target id '{0}'.
Java.Web.PCFVerification.PostOnChangeElement.InvalidPanelRefId = '{0}' is not the id of a panel containing the widget '{1}'
Java.Web.PCFVerification.PostOnChangeElement.InvalidPostOnChange = PostOnChange is not supported for widget type '{0}'.
Java.Web.PCFVerification.PostOnChangeElement.InvalidTargetId = Invalid target id '{0}'.
Java.Web.PCFVerification.PostOnChangeElement.TargetHasMultipleDeclaration = The target id '{0}' has multiple declarations in the same pcf file.
Java.Web.PCFVerification.PostOnChangeElement.WidgetNotExposed = '{0}' does not expose a widget called '{1}', cannot resolve '{2}'
Java.Web.PCFVerification.PrintLocationDetail.BadBaseLocation={0} is not a valid location id
Java.Web.PCFVerification.PrintSectionWidget.MustHaveOption = The print section widget must have an option
Java.Web.PCFVerification.PrintSectionWidget.SelectedValueAlreadyDefined = A parent scope already defines a symbol named "__selectedValue," which conflicts with the symbol automatically created for PrintSections
Java.Web.PCFVerification.RangeValueWidget.BothValueAndValues = Filter expression should not refer to both VALUE (a range member) and VALUES (the entire range)
Java.Web.PCFVerification.RangeValueWidget.IllegalNumberOfRows = Number of rows cannot be specified on a single-selection input.
Java.Web.PCFVerification.RangeValueWidget.IllegalShuttleList = shuttleList cannot be true on a single-selection input.
Java.Web.PCFVerification.RangeValueWidget.NoValueOrValues = Filter expression should refer to either VALUE (a range member) or VALUES (the entire range)
Java.Web.PCFVerification.ReferencedIteratorElement.IllegalFlags = Invalid flags value '{0}'.
Java.Web.PCFVerification.ReferencedIteratorElement.IllegalPosition = is not allowed to have child ReferencedIterator elements when inlined within other elements.
Java.Web.PCFVerification.ReflectElement.BoundInWrongPlace = trigger '{0}' is bound to a parent value of this widget, therefore must be located before this widget.
Java.Web.PCFVerification.ReflectElement.CannotHaveSubReflectCondition = cannot have sub ReflectCondition when there are multiple triggers.
Java.Web.PCFVerification.ReflectElement.CannotReflectOffTrigger = Cannot reflect off trigger '{0}' since it always does a PostOnChange when its value changes
Java.Web.PCFVerification.ReflectElement.CannotUseValueAndReflectCondition = cannot use both a "value" attribute and ReflectConditions in a Reflect.
Java.Web.PCFVerification.ReflectElement.CannotUseValueRange = Cannot use "valueRange" attribute when the reflector widget is not a RangeReflector.
Java.Web.PCFVerification.ReflectElement.DeprecatedReflection = Contains a deprecated "{0}" reflection configuration which sends AJAX request to server\: "{1}". Please convert to PostOnChange with DATA_ONLY target.
Java.Web.PCFVerification.ReflectElement.InvalidTriggerId = Invalid trigger id '{0}'.
Java.Web.PCFVerification.ReflectElement.MustDefineOneAttribute = Reflect element must define at least one attribute or have a child ReflectCondition.
Java.Web.PCFVerification.ReflectElement.MustSpecifyTrigger = must refer to at least one reflection trigger.
Java.Web.PCFVerification.ReflectElement.TriggerIdDoesNotExist = refers to a non-existent trigger ID '{0}'.
Java.Web.PCFVerification.RequireElement.IllegalPosition = is not allowed to have child Require elements when inlined within other elements.
Java.Web.PCFVerification.RequireElement.MustSpecifyType = Require element '{0}' must specify a type.
Java.Web.PCFVerification.RequireElement.InvalidType = Require element '{0}' has invalid type '{1}'.
Java.Web.PCFVerification.RowIteratorWidget.AttributeCannotBeSetWhenChildExists = '{0}' cannot be set when when child element, '{1}', exists.
Java.Web.PCFVerification.RowIteratorWidget.AttributeCannotBeSetWhenNested = '{0}' cannot be set when used inside another RowIterator.
Java.Web.PCFVerification.RowIteratorWidget.MultipleRowsSpecifyHeaders = Multiple rows within a RowIterator are implicitly specifying headers.
Java.Web.PCFVerification.RowIteratorWidget.MustHaveToolbar = An LV which performs paging must have an associated Toolbar.
Java.Web.PCFVerification.RowIteratorWidget.NestedIteratorFooter = Footers must be defined for all or none of the nested iterators.
Java.Web.PCFVerification.RowIteratorWidget.NestedIteratorHeader = Nested iterator cannot have label defined.  If header for the ListView is needed, move it outside of the nested iterator.
Java.Web.PCFVerification.RowIteratorWidget.NestedIteratorPaging = Paging must be off for a nested RowIterator.  Set pageSize to zero.
Java.Web.PCFVerification.RowSetRefWidget.CannotBeInHeaderSection = RowSetRef detected in the header section of a ListView.  Inline the Rows if they are to be header.
Java.Web.PCFVerification.RowTreeWidget.CannotMixWithOtherRow =  A ListView with RowTree cannot contain other Row or RowSetRef.
Java.Web.PCFVerification.RowTreeWidget.CantUseQuery = RowTree cannot use a query as its "value".
Java.Web.PCFVerification.RowTreeWidget.InvalidCellType = The cell type '{0}' is not supported for RowTree.
Java.Web.PCFVerification.RowTreeWidget.InvalidContentType = The type '{0}' is not valid.
Java.Web.PCFVerification.RowTreeWidget.MultipleIteratorsIsNotAllowed =  A ListView cannot contain another Iterator widget(s) when it contains a RowTree.
Java.Web.PCFVerification.RowTreeWidget.NoContentSpecified = No countentType was specified.
Java.Web.PCFVerification.RowTreeWidget.NoPageSizeSupport = RowTree does not support paging, please set pageSize to 0 or leave it blank.
Java.Web.PCFVerification.RowTreeWidget.ValueMustBeOfType = The "value" of a RowTree must be a '{0}'.
Java.Web.PCFVerification.RowWidget.DontUseVisibleToHideRows = Don't use "visible" to hide Rows in a RowIterator, since it breaks paging.  Filter the backing data instead.
Java.Web.PCFVerification.RowWidget.GroupHeaderCannotHaveCellWithVisibleExpression = Group header cannot have cell(s) that have visibility related expressions.
Java.Web.PCFVerification.RowWidget.GroupHeaderRowCannotWithVisibleExpression = Group header cannot have visibility related expressions.
Java.Web.PCFVerification.RowWidget.RenderAsSmartHeaderCannotBeFalse = RowWidget in the header section must have renderAsSmartHeader set to true.
Java.Web.PCFVerification.RowWidget.RenderAsSmartHeaderCannotBeInsideRowSet = RowWidget in a RowSet cannot have renderAsSmartHeader set to true.  Inline the header row instead.
Java.Web.PCFVerification.RowWidget.RenderAsSmartHeaderCannotBeTrue = RowWidget not in the header section cannot have renderAsSmartHeader set to true.  Please remove the attribute from the Row.
Java.Web.PCFVerification.RowWidget.UniqueCanOnlyBeSetUnderListViewIterator = "unique" can only be set when the cell is used directly under a Row inside a ListViewIterator.
Java.Web.PCFVerification.SearchPanelWidget.MustSpecifyId = Must specify the "id" for the SearchPanel when there are multiple sibling SearchPanels.
Java.Web.PCFVerification.SearchPanelWidget.SearchCriteriaMustBeSerializable = "searchCriteria" must be serializable.  It is of type '{0}'.
Java.Web.PCFVerification.SearchPanelWidget.SameCriteriaNameAndResultsName = the "criteriaName" and "resultsName" attributes must be different
Java.Web.PCFVerification.SecondPass.MaxInclusionLimitMet = Second-pass verify of PCF type {0} hit the maximum inclusion threshold of {1} sections
Java.Web.PCFVerification.SectionWidget.CircularReference = This section references itself: {0}
Java.Web.PCFVerification.SectionWidget.DuplicateExposedId = duplicate exposed id '{0}'.
Java.Web.PCFVerification.SectionWidget.DuplicateModes = This section is defined as a non-modal section, but there are other sections with that same id which likely are duplicates.
Java.Web.PCFVerification.SectionWidget.IllegalRefAttribute = Shared reference attribute: '{0}' should end with empty parentheses in case when no arguments provided.
Java.Web.PCFVerification.SectionWidget.IllegalCodeBlock = Code block found in a nested element.  Please move the Code block to the top-level element of the file.
Java.Web.PCFVerification.SectionWidget.IllegalId = has an id '{0}' that does not match file name '{1}'.
Java.Web.PCFVerification.SectionWidget.IllegalMode = mode cannot be specified on an element which is not the top-level element.
Java.Web.PCFVerification.SectionWidget.IllegalRequireModeType = Require type doesn't match other modes.  Expecting '{0}', was '{1}'.
Java.Web.PCFVerification.SectionWidget.InvalidModeParameters = Number of Requires does not match other modes.  Expected '{0}', got '{1}'.
Java.Web.PCFVerification.SectionWidget.InvalidRequiresType = Type of Requires does not match other modes.  Expected '{0}', got '{1}'.
Java.Web.PCFVerification.SectionWidget.ExposeElementTypeMismatch = This section has an expose element of type {0}, but the section with mode {1} has an expose element of type {2}. All modes of a given section must have the same set of expose elements.
Java.Web.PCFVerification.SectionWidget.ExposeNameMismatch = This section has an expose element named {0}, but the section with mode {1} has an expose element named {2}. All modes of a given section must have the same set of expose elements.
Java.Web.PCFVerification.SectionWidget.ExposeTypeMismatch = This section has an expose element with a valueType of {0}, but the section with mode {1} has an expose element with a valueType of {2}. All modes of a given section must have the same set of expose elements.
Java.Web.PCFVerification.SectionWidget.ModeValueTypeMismatch = ValueType mismatch in set of exposed elements.  The exposed elements in mode '{0}'  must have the same types as the ones in the default mode '{1}' vs '{2}'
Java.Web.PCFVerification.SectionWidget.ModeWidgetIdMismatch = Widget id mismatch in set of exposed elements.  The exposed elements in mode '{0}'  must have the ids named the same and in the same order as the ones in the default mode.
Java.Web.PCFVerification.SectionWidget.MultipleModes = This section defines one or more modes that are also found in another modal section with the same id, the identical mode(s)\: '{0}'
Java.Web.PCFVerification.SectionWidget.NoFlags = no flags with name '{0}' found on iterator '{1}'.
Java.Web.PCFVerification.SectionWidget.ParameterMismatch = This section requires parameters of type {0}, but the section with mode {1} requires parameters of type {2}. The parameter type names must match exactly
Java.Web.PCFVerification.SectionWidget.WrongNumberOfExposes = This section has {0} Expose elements, but the section with mode {1} has {2} Expose elements.  All modes of a given section must have the same set of Expose elements.
Java.Web.PCFVerification.SectionWidget.WrongNumberRequires = Wrong number of Requires.  Expecting '{0}', was '{1}'.
Java.Web.PCFVerification.TemplateWidget.CompilationError = An error occurred while verifying a template body: {0}.
Java.Web.PCFVerification.TemplateWidget.IsEmpty = Is an empty template tag, will render to nothing.
Java.Web.PCFVerification.TemplateWidget.SpecifiesBoth = Template must not have both a TemplatePanelContents child and a render call attribute
Java.Web.PCFVerification.TextValueWidget.AutoCompleteArgIdsHasNoEffect = Specifying "autoCompleteArgIds" has no effect when "autoComplete" is not specified.
Java.Web.PCFVerification.TextValueWidget.InvalidAutoCompleteArgIds = has an invalid "autoCompleteArgIds". There's no value widget with id '{0}' under '{1}' ({2}).
Java.Web.PCFVerification.TextValueWidget.SuspiciousValueType = TextInput and TextCell elements that could be editable only fully support a valueType of either String or some Number type.  Other types may work at runtime provided there's a coercion from that type to String, but may cease working in future versions.  In those cases, an explicit inputConversion should be used instead of relying on the runtime coercion behavior.
Java.Web.PCFVerification.TextValueWidget.AutoCompleteMarkupHasNoEffect = Specifying "enableAutoCompleteMarkup" has no effect when "autoComplete" is not specified.
Java.Web.PCFVerification.TitleBarWidget.MustHaveTitle = must have a "title" attribute defined, since it is not the Screen's title.
Java.Web.PCFVerification.ToolbarButtonSetRefWidget.IteratorMismatchTypeRequired = Iterator mismatch: Iterator '{0}' has no value type but iterator reference in button set requires one.
Java.Web.PCFVerification.ToolbarButtonSetRefWidget.IteratorMismatchTypeRedundant = Iterator mismatch: Iterator '{0}' has a value type but iterator reference in button set has none.
Java.Web.PCFVerification.ToolbarButtonSetRefWidget.MissingFlags = Some flags '{0}' expected on the ToolbarButtonSet's iterator '{1}' are not defined by the passed in iterator '{2}', this iterator defines the flags '{3}'.
Java.Web.PCFVerification.ToolbarButtonSetRefWidget.NumberOfIteratorsMismatch = Mismatch in number of iterators passed into toolbarbuttonset, expected '{0}', actual '{1}'.
Java.Web.PCFVerification.ToolbarButtonWidget.EmptyRestriction = Flags attribute contains empty restriction (possibly due to an extra comma)".
Java.Web.PCFVerification.ToolbarButtonWidget.FlagsNotFoundOnIterator = Flags '{0}' not found on iterator '{1}'.
Java.Web.PCFVerification.ToolbarButtonWidget.InvalidIterator = The "iterator" attribute does not refer to the id of an iterator widget.
Java.Web.PCFVerification.ToolbarButtonWidget.InvalidRestriction = Flags attribute contains invalid restriction\: "{0}".
Java.Web.PCFVerification.ToolbarButtonWidget.InvalidRestrictionType = Flags attribute contains invalid restriction type '{0}', allowed types are\: {1}.
Java.Web.PCFVerification.ToolbarFilterOptionElement.IllegalFilterExpectedBean = "filter" expects a "BeanBasedQueryFilter" instance, not '{0}'.
Java.Web.PCFVerification.ToolbarFilterOptionElement.IllegalFilterExpectedQuery = "filter" expects a "QueryBasedQueryFilter" instance, not '{0}', since the owning iterator uses a query.
Java.Web.PCFVerification.ToolbarFilterWidget.IteratorNotNeeded = No need to specify "iterator" attribute when this filter is a child of an Iterator widget.
Java.Web.PCFVerification.ToolbarFilterWidget.MustSpecifyIterator = does not specify an "iterator" attribute and is not a child of an Iterator widget.
Java.Web.PCFVerification.ToolbarWidget.IllegalReflectOnBottom = has "reflectOnBottom" set but is not defined directly under the Screen.
Java.Web.PCFVerification.TreeButtonWidget.CanOnlyBeInRowTree = TreeButtons can only be used with a RowTree.
Java.Web.PCFVerification.TreeButtonWidget.CannotFindAssociatedIterator = cannot find associated Iterator.
Java.Web.PCFVerification.TypekeyValueWidget.IllegalValueRangeOnReflectElement = Cannot add a Reflect element with a valueRange to a TypeKeyInput which implicitly reflects.
Java.Web.PCFVerification.TypekeyValueWidget.ValueMustBeTypekey = "value" expression is not a typekey.  It is of type [{0}].
Java.Web.PCFVerification.UnexpectedException = An exception occurred during verification of {0}: {1}
Java.Web.PCFVerification.ValueWidget.ConversionHasNoEffectWithNoPicker = The "conversionExpression" specified will never be used, since this input is not a picker and does not have any MenuItems which pick from another location.
Java.Web.PCFVerification.ValueWidget.ConversionHasNoEffectWithNoValue = Specifying "converter", "inputConversion" or "outputConversion" has no effect when "value" is not specified
Java.Web.PCFVerification.ValueWidget.DeprecatedSetter = uses the deprecated "setter" attribute. Use a writable expression in the "value" attribute instead.
Java.Web.PCFVerification.ValueWidget.IllegalTemplateCall = Input widget '{0}' cannot have children, as it is implemented using a widget template that includes multiple value widgets.
Java.Web.PCFVerification.ValueWidget.IllegalValueTypeMultipleOptions = specifies a valueType of {0} but the valueType must be assignable to one of [{1}]
Java.Web.PCFVerification.ValueWidget.IllegalValueTypeSingleOption = specifies a valueType of {0} but the valueType must be assignable to {1}
Java.Web.PCFVerification.ValueWidget.InvalidValueExpression = has an invalid value expression '{0}'
Java.Web.PCFVerification.ValueWidget.InvalidValueExpressionWithBadType = has an invalid value expression '{0}'.  Cannot use a '{0}' as the value of a widget.
Java.Web.PCFVerification.ValueWidget.MismatchedValueType = specifies a valueType of {0} but the actual value expression is of type {1}.
Java.Web.PCFVerification.ValueWidget.NoValueTypeString = has no valueType attribute specified, and the schema element has no default.  The expected type is {0}.
Java.Web.PCFVerification.ValueWidget.NullValueType = has a null value type.
Java.Web.PCFVerification.VariableElement.AlreadyDefined = The {0} '{1}' conflicts with a symbol with the same name that has already been defined in a parent scope.
Java.Web.PCFVerification.VariableElement.DuplicateVariable = A symbol with the name '{0}' has already been defined in this scope.
Java.Web.PCFVerification.VariableElement.InvalidName = has an invalid "{0}" attribute '{1}'.  First character must be alphabetical and all others alphanumeric. Java, Gosu and PCF keywords are prohibited.
Java.Web.PCFVerification.VariableElement.MustHaveType = Variable element '{0}' must specify a type.
Java.Web.PCFVerification.VariableElement.InvalidType = Variable element '{0}' has invalid type '{1}'.
Java.Web.PCFVerification.Widget.ConflictingId = '{0}' has same id ({1}) as {2} at '{3}'
Java.Web.PCFVerification.Widget.ContainsMoreThanOneProgress = contains more than one Progress widgets.
Java.Web.PCFVerification.Widget.IllegalRefreshOnProgressComplete = has "refreshOnProgressComplete" but contains no Progress widget.
Java.Web.PCFVerification.Widget.IllegalShortcut = "shortcut" attribute must be a single character, or "Shift" plus a single character.
Java.Web.PCFVerification.Widget.IllegalShortcutForIE7 = Alt+D and Alt+Shift+D shortcuts will not work in Internet Explorer 7.  Consider using a different shortcut key.
Java.Web.PCFVerification.WizardButtonsRefWidget.IllegalParent = cannot be added to '{0}'; only to a Location or ScreenRef.
Java.Web.PCFVerification.WizardStep.DuplicateId = Another step in this wizard also has the id '{0}'.
Java.Web.PCFVerification.WizardStepIterator.IllegalValueType = the "valueType" of a WizardStepIterator must be an array.



# properties from xmlcodegen_en.properties
Xml.Error.Particle.MinOccurs = particle did not satisfy minOccurs
Xml.Error.Type.Data.Init = Error initializing typedata for '{0}' ('{1}')
Xml.Error.Type.Data.Create.Exception = Unable to create type data for '{0}'
Xml.Error.Anonymous.Type.Exception = Anonymous type instances can only be assigned to their schema-defined containing elements, or to elements of type xs:anyType.
Xml.Error.Binary.Data.Already.Read = Binary data has already been read
Xml.Error.Property.Set.Exception = Unable to set property '{0}' of '{1}'
Xml.Error.Resource.Path.NotRelative = Resource path is not relative: '{0}'
Xml.Error.Resource.Path.NoResolve = Unable to resolve resource with location '{0}' relative to '{1}' with namespace '{2}' '{3}'
Xml.Error.MultipleMatches.Exception = Multiple matches for '{0}'
Xml.Error.SimpleValue.List.Exception = simple type list items must have at least one character
Xml.Error.SimpleValue.List.Whitespace.Exception = simple type list item '{0}' may not contain whitespace
Xml.Error.SimpleValue.List.Null.Exception = simple type list cannot contain null items
Xml.Error.SimpleValue.ID.Exception = The schema does not define an ID member for element nor does element have ID (qname='{0}')
Xml.Error.SimpleValue.Base64.Exception = Unable to serialize Base64 value
Xml.Error.SimpleValue.Enum.Exception = Enum value not found for type '{0}': '{1}'
Xml.Error.SimpleValue.Enum.Constant.Exception = Enum constant not found with name '{0}'
Xml.Error.SimpleValue.Enum.Value.Exception = value does not match enumeration '{0}'
Xml.Error.SimpleValue.Pattern.Value.Exception = value does not match pattern '{0}'
Xml.Error.SimpleValue.anyURI.Exception = Invalid xsd:anyURI
Xml.Error.SimpleValue.boolean.Exception = Invalid xsd:boolean
Xml.Error.SimpleValue.date.Exception = Invalid xsd:date
Xml.Error.SimpleValue.dateTime.Exception = Invalid xsd:dateTime
Xml.Error.SimpleValue.decimal.Exception = Invalid xsd:decimal
Xml.Error.SimpleValue.double.Exception = Invalid xsd:double
Xml.Error.SimpleValue.duration.Exception = Invalid xsd:duration
Xml.Error.SimpleValue.float.Exception = Invalid xsd:float
Xml.Error.SimpleValue.gDay.Exception = Invalid xsd:gDay
Xml.Error.SimpleValue.gMonth.Exception = Invalid xsd:gMonth
Xml.Error.SimpleValue.gMonthDay.Exception = Invalid xsd:gMonthDay
Xml.Error.SimpleValue.gYear.Exception = Invalid xsd:gYear
Xml.Error.SimpleValue.gYearMonth.Exception = Invalid xsd:gYearMonth
Xml.Error.SimpleValue.time.Exception = Invalid xsd:time
Xml.Error.SimpleValue.facet.constraints.Exception = Value '{0}' violated one or more facet constraints of simple type definition: '{1}'
Xml.Error.SimpleValue.Union.Exception = "value does not match any of xsd:union members '{0}'"
Xml.Error.Namespace.Prefix.Exception = Namespace not found for prefix '{0}'
Xml.Error.Namespace.QName.Exception = Invalid QName '{0}'
Xml.Error.Namespace.NCName.Empty.Exception = NCName cannot be empty
Xml.Error.Namespace.NCName.StartCharacter.Exception = Invalid NCName '{0}' ( invalid start character )
Xml.Error.Namespace.NCName.InvalidCharacter.Exception = Invalid NCName '{0}' ( invalid character at position '{1}' )
Xml.Error.Namespace.NCName.Colon.Exception = Invalid NCName '{0}' ( contains a colon )
Xml.Error.Facet.Validation.fractionDigits.Exception = fractionDigits '{0}' > '{1}'
Xml.Error.Facet.Validation.length.Exception = length '{0}' != '{1}'
Xml.Error.Facet.Validation.lessthan.Exception = value must be less than '{0}'
Xml.Error.Facet.Validation.nogreaterthan.Exception = value must be no greater than '{0}'
Xml.Error.Facet.Validation.maxLength.Exception = length '{0}' > '{1}'
Xml.Error.Facet.Validation.minLength.Exception = length '{0}' < '{1}'
Xml.Error.Facet.Validation.minExclusive.Exception = value must be greater than '{0}'
Xml.Error.Facet.Validation.minInclusive.Exception =  value must be no less than '{0}'
Xml.Error.Facet.Validation.wrongtype.Exception = Found '{0}' constraint on simple type extending primitive datatype '{1}'
Xml.Error.Parse.LinkRef.Exception = Unable to find ID for IDREF '{0}'
Xml.Error.Parse.Generic.Simple.Exception = Could not parse '{0}'
Xml.Error.Parse.File.Exception = Unable to parse file '{0}'
Xml.Error.Parse.InputStream.Exception = Unable to parse input stream
Xml.Error.Parse.InputReader.Exception = Unable to parse input reader
Xml.Error.Parse.URL.Exception = Unable to parse URL '{0}'
Xml.Error.Parse.File.TypeWrong.Exception = Please use '{0}'.parse( java.io.File ) to parse a file
Xml.Error.Parse.Element.Exception = Please use XmlElement.parse( java.io.File ) to parse a file
Xml.Error.Parse.Anonymous.Element.Exception = parse() cannot be called on an anonymous element type
Xml.Error.Parse.anyAttribute.Exception = The attribute '{0}' matching xs:anyAttribute could not be resolved to an attribute definition.
Xml.Error.Parse.Generic.Exception = Xml Parse Error, details: '{0}'
Xml.Error.Parse.Exception = Unable to create parser for '{0}' '{1}' using schema root '{2}'
Xml.Error.Parse.XML.Exception = Unable to parse XML from '{0}' '{1}' using schema root '{2}'
Xml.Error.Parse.Root.Element.Exception = Invalid root element. Expected '{0}', but was '{1}', QName '{2}'
Xml.Error.Sort.Empty = Matched empty
Xml.Error.Sort.Exception = XmlSortException details: '{0}'
Xml.Error.Sort.Children.Exception = Unable to process children of element '{0}'. Expected one of '{1}'
Xml.Error.Sort.Children.Generic.Exception = Unable to process children of element '{0}'.
Xml.Error.Sort.All.Exception = Sort xs:all Exception '{0}'
Xml.Error.Sort.Empty.Choice.Exception = Empty xsd:choice
Xml.Error.Sort.Extra.Elements.Exception = Extra elements found: '{0}'
Xml.Error.Sort.Match.Generic.Exception = Match error
Xml.Error.Sort.Match.Ignore.Exception = Match error
Xml.Error.Sort.Match.minOccurs.Exception = minOccurs not satisfied; expected at least '{0}' but found '{1}'
Xml.Error.Sort.Match.any.Exception = Unexpected element for xsd:any, processContents = strict: '{0}'
Xml.Error.Sort.Match.any.nomatch.Exception = No matches for xsd:any, namespace = '{0}', targetNamespace = ['{1}']
Xml.Error.Sort.Unexpected.Child.Element = Unexpected child element: '{0}'
Xml.Error.Sort.Unexpected.Child.Elements = Unexpected child elements: '{0}'
Xml.Error.URI.Exception = Invalid URI: '{0}'
Xml.Error.IDREF.simpleValueToEnumValue.Exception = Unresolved IDREF. Attempt to simpleValueToEnumValue IDREF outside of parse operation.
Xml.Error.Import.Namespace.Exception = Namespace not found for imported schema '{0}'
Xml.Error.Import.Namespace.missmatch.Exception = The namespace attribute, '{0}', of an <import> element information item must be identical to the targetNamespace attribute, '{1}', of the imported document
Xml.Error.Import.Namespace.Include.Exception = src-include.2.1: The targetNamespace of the referenced schema, '{0}', must be identical to that of the including schema, '{1}'
Xml.Error.SimpleType.Contents.Restriction.Exception = xs:simpleType expected to contain xs:restriction
Xml.Error.Element.Name.Exception = Element name expected to be '{0}', but was '{1}'
Xml.Error.ComplexType.Contents.Exception = xs:complexType expected to contain either xs:complexContent or xs:simpleContent
Xml.Error.ComplexType.Base.Exception = Expected base type name to be '{0}', but was '{1}'
Xml.Error.ComplexType.Contents.Extension.Restriction.Exception = xs:complexType expected to contain either xs:complexContent or xs:simpleContent containing either xs:extension or xs:restriction
Xml.Error.NS.Attributes.NoSet.Exception = Setting xmlns attributes directly is not supported.
Xml.Error.xsiType.NoSet.Exception = Setting xsi:type directly is not supported on types other than xs:anyType.
Xml.Error.xsiNil.NoSet.Exception = Setting xsi:nil directly is not supported.
Xml.Error.Validate.Exception = Failed to validate XML from '{0}' using schema root '{1}'
Xml.Error.Validate.Line.Column.Exception = Failed to validate XML from '{0}' using schema root '{1}' at line '{2}' column '{3}'
Xml.Schema.Parse.Root.missmatch.Exception = Expected schema root element to be '{0}', but was '{1}'
Xml.Schema.Parse.Qname.Attribute.Exception = Unable to parse qname '{0}' of type '{1}'
Xml.Schema.Parse.Qname.List.Exception = Unable to parse qname list '{0}' of type '{1}'
Xml.Schema.Parse.Exception = Could not parse schema '{0}'
Xml.Schema.Parse.Path.Exception = Could not parse schema '{0}' '{1}'
Xml.Schema.Index.Exception = Error indexing schema '{0}'
Xml.Schema.Resource.Process.Exception = Schema not found for system id '{0}' namespace '{1}' with base url '{2}'
Xml.Schema.Resource.Resolve.Exception = Schema not found with namespace '{0}')
Xml.Java.Type.Mapping.Exception = Unable to map '{0}' to a schema type
Xml.Codegen.Handler.Resource.Process.Exception = Unable to process resource '{0}' using resource handler '{1}'
Xml.Codegen.TempPath.UnableToCreate.Exception = Unable to create temp path
Xml.Codegen.Fingerprint.UnableToRead.Exception = Unable to read fingerprint
Xml.Codegen.Compile.Exception = Unable to compile generated code with command line: '{0}'
Xml.Codegen.FileOpen.Exception = Unable to open file: '{0}'
Xml.Codegen.Generate.Exception = Unable to generate XML
Xml.Fetch.Exception = Unrecognized root element of XML at '{0}'; Expected '{1}' or '{2}', but was '{3}'
Xml.Wsdl.Parse.Exception = Unable to parse Wsdl at location '{0}'
Gx.BranchDuplicatesLeaf = Tried to create branch where leaf already existed
Gx.Coerce = Unable to coerce object '{0}' of type {1} to an iterable
Gx.NoProperty = No property '{0}' found on type {1}
Gx.CouldNotMap = Could not map property {0}
Gx.UnableToResolveModel = Unable to resolve model with path '{0}' or with schema package '{1}'
Gx.UnableToResloveType.Xml = Unable to resolve type specification: {0}. Resolution was only necessary since an 'xmlType' attribute was not specified
Gx.UnableToMap =Unable to map type {0} to an xml type. Resolution was only necessary since an 'xmlType' attribute was not specified
Gx.UnableToResloveType = Unable to resolve type specification: {0}
Gx.XmlType.UnableToMap = xmlType {0} was specified in GX model, but unable to map {1} to a schema type
Gx.XmlType.Wrong = Wrong xmlType found in GX model. Expected {0}, but was {1}
Gx.DuplicateLeaf = Tried to create leaf where {0} already existed
Gx.Label.Empty = Label should not be empty
Gx.Label.ReservedWord = Label name {0} is a reserved Java keyword
Gx.Label.DefaultReserved = Label name {0} is reserved
Gx.Label.NotJavaIdentifier = Label '{0}' is not a valid Java identifier
Gx.Label.Duplicate = Duplicate label {0}


# properties from permission-codegen_en_US.properties
Java.PermissionsCodegen.Validation.NeitherFound=Did not find {0} or {1}.
Java.PermissionsCodegen.Validation.OneOfTwoFound=Found {0} but not {1}.
Java.PermissionsCodegen.Validation.CannotShadow=Cannot shadow {0}.
Java.PermissionsCodegen.Validation.CannotDetermineEntityName=Cannot determine entity name
Java.PermissionsCodegen.Validation.PermissionKeyMustBeDeclared=Permission key must be declared explicitly in this file
Java.PermissionsCodegen.Validation.ContainOnlyTagsThatDeclarePersmissionKeys=Internal versions of file (-pl and -app) must contain only tags that declare permission keys
Java.PermissionsCodegen.Validation.EntityAttributeImproperCase=Entity attribute not in proper case\: {0}
Java.PermissionsCodegen.Validation.PermKeyAttributeImproperCase=PermKey attribute not in proper case\: {0}
Java.PermissionsCodegen.Validation.PermKeyCannotBeOverridden=Permission key cannot be overridden
Java.PermissionsCodegen.Validation.PermKeyMustBeDeclaredWith=Permission key must be declared with {0}
Java.PermissionsCodegen.Validation.CustomHandlerMustNotAppear=Custom handler class must not appear in configurable version of file
Java.PermissionsCodegen.Validation.InternalAttributeMustNotAppear=Internal attribute must not appear in configurable version of file
Java.PermissionsCodegen.Validation.ExternalAttributeMustNotAppear=External attribute must not appear in configurable version of file
Java.PermissionsCodegen.Validation.CannotDecalreBoth=Cannot declare both internal and external
Java.PermissionsCodegen.Validation.WrapPermKeyAttributeNotDefined=wrapPermKey attribute value not yet defined\: {0}
Java.PermissionsCodegen.Validation.MustNotWrap=Must not wrap {0}
Java.PermissionsCodegen.Validation.WrapPermKeyAttributeImproperCase=wrapPermKey attribute value not in proper case\: {0}
Java.PermissionsCodegen.Validation.InvalidSystemPermTypeCodes=Invalid SystemPermType codes\: {0}
Java.PermissionsCodegen.Validation.DoNotIncludeNonEssentialAttributes=When declaring a permission with external\=\"true\", please do not include any non-essential attributes
Java.PermissionsCodegen.Validation.DoNotIncludeChildElements=When declaring a permission with external\=\"true\", please do not include any child elements
Java.PermissionsCodegen.Validation.SpecifyInternalTrueOrFalse=When providing a custom handler class, please explicitly specify internal\=\"true\" or internal\=\"false\"
Java.PermissionsCodegen.Validation.SpecifyInternalTrueFalseExternalTrue=When overriding a permission originally declared with internal\=\"true\", please explicitly specify internal\=\"true\", internal\=\"false\", or external\=\"true\"
Java.PermissionsCodegen.Validation.SpecifyExternalTrueFalseInternalTrue=When overriding a permission originally declared with external\=\"true\", please explicitly specify external\=\"true\", external\=\"false\", or internal\=\"true\"



# properties from entity-codegen_en_US.properties
Java.EntityCodegen.ErrorsCheckLogs={0} errors occurred during code generation. Check the logs for details.
Java.EntityCodegen.WildCardLowerBoundsNotSupported={0}, wildcard with lower bound is not supported
Java.EntityCodegen.InvalidTypeForInterface={0} is not a valid type for an interface implemented by a class
Java.EntityCodegen.MoreThanOneArg={0} must have exactly one argument, but got {1}
Java.EntityCodegen.UnexpectedFileExtension=Can't parse file {0}\: unexpected file extension.
Java.EntityCodegen.ExpectedParameterizedType=Expected {0} to be a parametrized type when determining type arguments for {1} implemented by {2}
Java.EntityCodegen.InterfaceImplementedByTwoClasses=Interface {0} implemented by two different classes, {1} and {2}
Java.EntityCodegen.InterfaceNotImplemented=Interface {0} is not implemented on entity {1}.
Java.EntityCodegen.TypeParamMismatch=Type parameters {0} don't match type arguments {1}
Java.EntityCodegen.TypeVariableMissing=type variable map {0} does not contain a mapping for type variable {1}



# properties from entity-metadata_en_US.properties
Java.EntityMetadata.Validation.AssociationPropertyConflicts = Association property {0} conflicts with field declared at {1}:{2}
Java.EntityMetadata.Validation.EffDatedBranchOnNonEffDatedContainer = Entity {0} declares an effDatedBranchesField ({1}) but is not an effdatedcontainer
Java.EntityMetadata.Validation.CheckConstraintMissingPredicate = checkconstraint is missing a predicate
Java.EntityMetadata.Validation.ColumnNameAlreadyDefined = Column name {0} is already defined at {1}:{2}
Java.EntityMetadata.Validation.ColumnDifferentTypeOnSubtype = Column name {0} is defined on another subtype at {1}:{2} but has a different type",
Java.EntityMetadata.Validation.ColumnDifferentNullabilityOnSubtype = Column name {0} is defined on another subtype at {1}:{2} but has a different nullability",
Java.EntityMetadata.Validation.ColumnDifferentTypelistOnSubtype = Column name {0} is defined on another subtype at {1}:{2} but has a different typelist",
Java.EntityMetadata.Validation.ColumnDifferentTypesAcrossSubtypes = Column name {0} is defined on another subtype at {1}:{2}. Fields with the same column names on different subtypes must either both be columns or both be typekeys",
Java.EntityMetadata.Validation.CycleDetected = Cycle detected in metadata. {0}
Java.EntityMetadata.Validation.DateTimeOrderingNonExistentColumn = Column {0} declared on datetimeordering does not exist on containing entity
Java.EntityMetadata.Validation.DelegateImplementedByRequiredType = Entity {0} with base type {1} is attempting to include a delegate {2} that requires type {3}
Java.EntityMetadata.Validation.DuplicateField = Duplicate field {0}: declaration at {1}:{2} conflicts with declaration at {3}:{4}
Java.EntityMetadata.Validation.EffDatedBranchDoesntDeclareContainer = Entity {0} (effdatedbranch) does not define effDatedContainerField
Java.EntityMetadata.Validation.EffDatedBranchDeclaresNonExistentContainer = Entity {0} (effdatedbranch) specifies effDatedContainerField {1} that does not exist
Java.EntityMetadata.Validation.EffDatedBranchDeclaresNonFkContainerField = Entity {0} (effdatedbranch) specifies effDatedContainerField {1} that is not a foreignkey
Java.EntityMetadata.Validation.EffDatedBranchTypeDoesNotExist = Entity {0} (effdated) declares an effDatedBranchType {1} that does not exist
Java.EntityMetadata.Validation.EffDatedBranchTypeNotEffDatedBranch = Entity {0} (effdated) declares an effDatedBranchType {1} that is not an EffDatedBranch
Java.EntityMetadata.Validation.EffDatedBranchFieldNotAField = Entity {0} (effdatedcontainer) declares a branches field {1} that is not a field
Java.EntityMetadata.Validation.EffDatedBranchFieldNotAnArray = Entity {0} (effdatedcontainer) declares a branches field {1} that is not an array
Java.EntityMetadata.Validation.EffDatedBranchFieldNotEffDatedBranch = Entity {0} (effdatedcontainer) declares a branches field {1} that does not refer to an effdatedbranch
Java.EntityMetadata.Validation.EffDatedContainerDoesntDeclareBranchField = Entity {0} is an effdatedcontainer but does not declare an effDatedBranchesField
Java.EntityMetadata.Validation.EffDatedContainerDoesntDeclareRegistryTable = Entity {0} is an effdatedcontainer but does not declare an effDatedRegistryTableName
Java.EntityMetadata.Validation.EffDatedContainerNotAnEffDatedBranch = Entity {0} declares an effDatedContainerField ({1}) is not an effdatedbranch
Java.EntityMetadata.Validation.EffDatedBranchPointsToNonEffDatedContainer = Entity {0} (effdatedbranch) effDatedContainerField {1} points to entity ({2}) that is not an effDatedContainer
Java.EntityMetadata.Validation.EffDatedUndeclaredEffDatedBranchType = Entity {0} (effdated) does not declare an effDatedBranchType
Java.EntityMetadata.Validation.NonEffDatedDeclaresRegistry = Entity {0} declares an effDatedRegistryTableName ({1}) but is not an effdatedcontainer
Java.EntityMetadata.Validation.EntityFinalAndAbstract = Entity {0} is marked both final and abstract.
Java.EntityMetadata.Validation.EntityTableNameHasInvalidChar = The table name {0} of the entity {1} contains a character other than a-z, a number or an underscore
Java.EntityMetadata.Validation.EntityTableNameTooLong = The table name {0} of entity {1} exceeds the maximum allowed length {2}
Java.EntityMetadata.Validation.IndexRefToIDNotUnique = Index {0} that contains reference to ID column is not declared unique
Java.EntityMetadata.Validation.IncludeNonExistentDelegate = Entity {0} is attempting to include a delegate {1} that does not exist
Java.EntityMetadata.Validation.IndexHasDenormsButNotID = Unique index {0} contains denorm columns but doesn't include the ID column. A unique index cannot contain denorm columns unless it also contains the ID column.
Java.EntityMetadata.Validation.IndexKeyPositionDuplicate = The keyposition value {0} has been previously declared at {1}:{2}
Java.EntityMetadata.Validation.IndexKeyPositionRangeError = The keyposition must be between 1 and {0}
Java.EntityMetadata.Validation.IndexColNameDuplicate = The indexcol name {0} has been previously declared at {1}:{2}
Java.EntityMetadata.Validation.IndexColNameInvalid = The indexcol has a name {0} that does not resolve to a column in the containing entity {1}
Java.EntityMetadata.Validation.IndexDuplicated = Duplicate index with the same columns in the same key and sort order on the same table was declared on the index named {0} at {1}:{2}
Java.EntityMetadata.Validation.IndexNameTooLong = The name of the index ({0}) exceeds the maximum allowed length {1}
Java.EntityMetadata.Validation.IndexNameDuplicated = Duplicate index name {0}. Previously declared at {1}:{2}
Java.EntityMetadata.Validation.TableNameDuplicated = Entities {0} and {1} declare the same table name {2}
Java.EntityMetadata.Validation.RemoveIndexDuplicate = Duplicate remove-index referring to index {0} on entity {1}. First declaration at {2}:{3}
Java.EntityMetadata.Validation.FieldDuplicated = Field {0} conflicts with previous declaration at {1}:{2}
Java.EntityMetadata.Validation.RemoveIndexForNonExistentIndex = remove-index refers to an index {0} that does not exist on entity {1}"n
Java.EntityMetadata.Validation.RemoveIndexForNonPerfIndex = remove-index refers an index {0} that is not perf-only. Only indexes that are non-unique, or those that include the ID column, may be removed
Java.EntityMetadata.Validation.SubtypeRefersToSelf = subtype {0} refers to itself as supertype
Java.EntityMetadata.Validation.SubtypeRefersToNonExistentSuper = subtype {0} refers to a supertype {1} that does not exist
Java.EntityMetadata.Validation.EntityExtendsFinal = entity {0} cannot extend an entity ({1}) marked final.
Java.EntityMetadata.Validation.FinalEntityHasTypelistTableName = entity {0} is final but specifies a typelistTableName {1}
Java.EntityMetadata.Validation.ValidateTypekeyNonExistentColumn = validatetypekey on entity {0} refers to non-existent column {1}
Java.EntityMetadata.Validation.ValidateTypekeyNonTypekeyColumn = validatetypekey on entity {0} refers to a non-typekey column {1}
Java.EntityMetadata.Validation.ValidateTypekeyBadTypecode = validatetypekey on entity {0} refers contains a non existent typecode {1}
Java.EntityMetadata.Validation.ViewRefersToNonPeristent = View entity {0} refers to a non-persistent primaryEntity {1}
Java.EntityMetadata.Validation.ViewRefersToNonExistent = View entity {0} specifies a primary entity {1} that does not exist
Java.EntityMetadata.Validation.ViewRefersToNonExistentSuper = View entity {0} specifies a super entity {1} that does not exist
Java.EntityMetadata.Validation.ViewBadHierarchy = The primary entity {0} specified on {1} is in a different hierarchy specified on it's super type {2}
Java.EntityMetadata.Validation.ArrayOverrideRefersToNonArray = Array override refers to a field {0} that is not an array
Java.EntityMetadata.Validation.EdgeFKOverrideRemovesExtract = Edge foreign key override cannot remove extractability from {0}
Java.EntityMetadata.Validation.EdgeFKOverrideRemovesOverlap = Edge foreign key override cannot remove overlap table from {0}
Java.EntityMetadata.Validation.EdgeFKOverrideRefersToNonEFK = Edge foreign key override refers to a field {0} that is not an edge foreign key
Java.EntityMetadata.Validation.ColumnOverrideChangesNull = Column override of {0} cannot allow null because the base model does not allow null
Java.EntityMetadata.Validation.EntityNotExtendable = Non-extendable entity violation. prohibited {0}
Java.EntityMetadata.Validation.EntityExtensionImplementsRequiresField = Extension of entity {0} declares that it implements entity {1}, which has a required field {2}. Extensions cannot introduce new required fields to entities.
Java.EntityMetadata.Validation.EntityExtensionRefersToNonExistent = Extension refers to non-existing entity {0}
Java.EntityMetadata.Validation.EntityExtensionDeclaressRequiresField = Field {0} declared on extension is marked required. Extensions cannot declare required fields.
Java.EntityMetadata.Validation.EntityExtensionTypeMismatch = Extension type mis-match. Entity {0} cannot be extended with extension type {1}
Java.EntityMetadata.Validation.FKOverrideChangesNullable = Foreign key override of {0} cannot allow null because base does not allow null
Java.EntityMetadata.Validation.FKOverrideRefersToNonFK = Foreign key override refers to a field {0} that is not a foreign key
Java.EntityMetadata.Validation.FKOverrideChangesImportable = Foreign key override of {0} cannot allow importable because base does not allow it
Java.EntityMetadata.Validation.OneToOneOverrideRefersToNonOtoO = One to one override refers to a field {0} that is not a one to one
Java.EntityMetadata.Validation.OneToOneOverrideRefersToNonExistent = One to one override refers to a non-existent field {0}
Java.EntityMetadata.Validation.OverrideTagNotInList = A tag named {0} is defined on override {1} but not defined in tags.lst
Java.EntityMetadata.Validation.OverrideTagAlreadyDefined = A tag named {0} is already defined on field {1}
Java.EntityMetadata.Validation.OverrideTagDuplicated = Duplicate tag {0} declared. Original declaration at {1}:{2}
Java.EntityMetadata.Validation.ColumnOverrideRemovesLinguistic = Column override of {0} cannot remove linguistic search from base
Java.EntityMetadata.Validation.ColumnOverrideCreatesUniqLocalization = Column override cannot create a unique localization for column {0} on effdated entity {1}
Java.EntityMetadata.Validation.ColumnOverrideRefinesLocalizaiton = Column override of {0} cannot redefine localization.  The column is already localized!
Java.EntityMetadata.Validation.ColumnOverrideRefersToNonColumn = Column override refers to a field {0} that is not a column
Java.EntityMetadata.Validation.OverrideNonExtendableViolation = Non-extendable entity violation by extension of field {0}. Prohibited {1}
Java.EntityMetadata.Validation.ColumnOverrideUsesProhibitedParam = Non-extendable entity has prohibited columnParam {0} on override of column {1}
Java.EntityMetadata.Validation.TypekeyOverrideChangesNull = Typekey override of {0} cannot allow null because the base model does not allow null
Java.EntityMetadata.Validation.TypekeyOverrideRefersToNonTypekey = Typekey override refers to a field {0} that is not a typekey
Java.EntityMetadata.Validation.ArrayNoFK = Array {0} cannot get foreignkey from entity {1}
Java.EntityMetadata.Validation.OneToOneNoFK = Onetoone {0} cannot get required foreignkey from entity {1}
Java.EntityMetadata.Validation.ArrayHasTooManyLinks = Array {0} has {1} links pointing to it from {2}
Java.EntityMetadata.Validation.ArrayRefersToNonExportable = Exportable array {0} cannot use non-exportable entity {1}
Java.EntityMetadata.Validation.ArrayRefersToNonPersistent = Array {0} on persistent entity {1} cannot use non-persistent entity {2}
Java.EntityMetadata.Validation.ArrayRefersToNonExistent = Array {0} refers to non-existent entity {1}
Java.EntityMetadata.Validation.ArrayRefersToNonVersionable = Array {0} on versionable entity {1} cannot use non-versionable entity {2}
Java.EntityMetadata.Validation.ArrayRefersToNonExtendable = Array {0} uses a subtype-map but refers to non-extendable entity {1}
Java.EntityMetadata.Validation.ColumnUsesNonExistentDatatype = Column {0} uses a non-existent datatype {1}
Java.EntityMetadata.Validation.ColumnHasNoDatatype = Column {0} does not specify a datatype
Java.EntityMetadata.Validation.ColumnNameHasInvalidChar = The column name {0} of the field {1} contains a character other than a-z, a number or an underscore
Java.EntityMetadata.Validation.ColumnNameTooLong = The column name {0} of field {1} exceeds the maximum allowed length {2}
Java.EntityMetadata.Validation.ColumnNameDoesntStartWithLetter = The column name {0} of field {1} does not start with a letter
Java.EntityMetadata.Validation.ColumnParamNotUnique = Field {0} redeclares the columnParam {1} previously declared at {2}:{3}
Java.EntityMetadata.Validation.ColumnParamUndefined = Field {0} specifies a columnParam {1} that is not defined by the data type {2}
Java.EntityMetadata.Validation.EdgeFKEntityExists = The edgeForeignKey {0} has an edge table entity name of {1}. An entity with that name already exists
Java.EntityMetadata.Validation.EdgeFKTableNameHasInvalidChar = The table name {0} of the edgeForeignKey {1} contains a character other than a-z, a number or an underscore
Java.EntityMetadata.Validation.EffDatedColLocalizationUnique = The localization on the eff dated column {0} is unique
Java.EntityMetadata.Validation.TagMultiplyDeclared = Tag {0} is declared multiple times on field {1}
Java.EntityMetadata.Validation.TagDoesNotExist = Tag {0} on field {1} does not exist in tags.lst
Java.EntityMetadata.Validation.FKDeclaredOnTempEntity = Foreign key {0} declared on temporary entity {1}
Java.EntityMetadata.Validation.LinkToNonPersistent = Link {0} from persistent entity {1} points to non-persistent entity {2}
Java.EntityMetadata.Validation.LinkToNonExistent = Link {0} from entity {1} points to non-existent entity
Java.EntityMetadata.Validation.LocalizationOnNonPersistent = Localized column {0} declared on nonPersistentEntity {1}. Localized columns can only be declared on persistent entities
Java.EntityMetadata.Validation.LoadablOtONonLoadable = The loadable onetoone {0} on loadable entity {1} refers to loadable entity {2} with foreign key link back to owner that is not loadable
Java.EntityMetadata.Validation.LoadablOtONonNullable = Loadable entity {0} has a non-nullable onetoone with a non-loadable entity {1}
Java.EntityMetadata.Validation.TooManyAutoIncs = More than one autoincrement column exists on table {0}
Java.EntityMetadata.Validation.ScalableColumnOnNonEffDated = Column {0} is declared as scalable but is not on an effdated entity.
Java.EntityMetadata.Validation.SourceFKNonExistent = Search column {0} declares a sourceForeignKey {1} that doesn't exist on entity {2}
Java.EntityMetadata.Validation.SourceFKNotFK = Search column {0} declares a sourceForeignKey {1} that isn't a foreign key
Java.EntityMetadata.Validation.SourceFKIsEffDatedFK = The sourceForeignKey on search column {0} is effdated. Only regular foreign keys can be used for searchForeignKeys
Java.EntityMetadata.Validation.SearchDenormOnNonVersionable = Search column {0} cannot exist on non-versionable entity {1}
Java.EntityMetadata.Validation.SourceFKImportable = Search column {0} exists on loadable entity, but declares a sourceForeignKey {1} that is importable against existing objects
Java.EntityMetadata.Validation.SourceColumnNonExistent = Search column {0} declares a sourceColumn {1} that does not exist on source entity {2}" = Search column {0} declares a sourceColumn {1} that does not exist on source entity {2}
Java.EntityMetadata.Validation.SourceColumnLocalized = Search column {0} declares a sourceColumn {1} that is localized. Localized columns cannot be denormalized
Java.EntityMetadata.Validation.SourceColumnNotColumn = Search column {0} declares a sourceColumn {1} that is not a column
Java.EntityMetadata.Validation.SourceEntityNotVersionable= Search column {0} references source entity {1}, which is not versionable. Source entities must be versionable
Java.EntityMetadata.Validation.SourceSubtypeDoesntExist = Search column {0} declares a sourceSubtype {1} that doesn't exist
Java.EntityMetadata.Validation.SourceSubtypeHierachyError = Search column {0} declares a sourceSubtype {1} that is not a subtype of the source entity {2} referred to by sourceForeignKey {3}
Java.EntityMetadata.Validation.SourceTypekeyNonExistent = Search column {0} declares a sourceTypekey {1} that does not exist on source entity {2}
Java.EntityMetadata.Validation.SourceTypekeyNotTypekey = Search column {0} declares a sourceTypekey {1} that is not a typekey
Java.EntityMetadata.Validation.TypekeyDefaultNotInTypelist = Typekey {0} specifies a default value {1} that does not exist in the typelist {2}
Java.EntityMetadata.Validation.TypekeyFilterPathNotReachable = Typekey filter name {0} on typekey {1} does not resolve to a reachable field
Java.EntityMetadata.Validation.TypekeyFilterPathNotTypekey = Typekey filter name {0} on typekey {1} does not resolve to a typekey field
Java.EntityMetadata.Validation.TypekeyTypelistNonExistent = Typekey {0} refers to non-existent typelist {1}
Java.EntityMetadata.Validation.ViewColumnPathNotScalarOrFK = View column {0} on view entity {1} specifies a path {2} that does not resolve to a column or foreign key
Java.EntityMetadata.Validation.ViewColumnPathInvalid = View column {0} on view entity {1} specifies a path {2} that is invalid
Java.EntityMetadata.Validation.ViewColumnPathContainsArray = View entity column {0} refers to an array {1} in it's path
Java.EntityMetadata.Validation.ViewColumnPathContainsEffDatedLink = View entity column {0} refers to an effdated link {1} in it's path
Java.EntityMetadata.Validation.ViewTypekeyPathNotTypekey = View typekey {0} on view entity {1} specifies a path {2} that does not resolve to a typekey
Java.EntityMetadata.Validation.CategoryListTypelistNonExistent = Typecode {0} categorylist refers to typelist {1} that does not exist
Java.EntityMetadata.Validation.TypelistFilterDuplicated = Typelist {0} contains multiple definitions for filter {1}. Original definition is at {2}:{3}
Java.EntityMetadata.Validation.TypelistTableNameCollision = Typelists {0} and {1} declare the same table name {1
Java.EntityMetadata.Validation.TypelistTableNameHasInvalidChar = The table name {0} of the entity {1} contains a character other than a-z, a number or an underscore
Java.EntityMetadata.Validation.TypelistTableNameTooLong = The table name {0} of entity {1} exceeds the maximum allowed length {2}
Java.EntityMetadata.Validation.ExcludeHasNonExistentCode = The exclude element contains a code {0} that does not exist in the owning typelist {1}
Java.EntityMetadata.Validation.IncludeHasNonExistentCode = The include element contains a code {0} that does not exist in the owning typelist {1}
Java.EntityMetadata.Validation.CategoryTypelistNonExistent = Typecode category {0} refers to a typelist {1} that does not exist
Java.EntityMetadata.Validation.CategoryTypecodeNonExistent = Typecode category refers to typecode {0}.{1} that does not exist
Java.EntityMetadata.Validation.TypelistExtensionAddsToFinalTypelist = Extension to final typelist {0} declares new typecode {1}
Java.EntityMetadata.Validation.TypelistExtensionExtendsNonExistent = Extension refers to non-existing typelist {0}
Java.EntityMetadata.Validation.InternalTypelistExtensionWrongFile = Internal typelist extension {0} is not in an internal typelist extension file
Java.EntityMetadata.Validation.MultipleDescriptionsInTypelist = Multiple descriptions for typelist {0} declared in extensions. First description declared at {1}:{2}
Java.EntityMetadata.Validation.TypecodeDuplicated = Duplicate typecode {0}. First declaration is at {1}:{2}
Java.EntityMetadata.Validation.TypecodeTooLong = Typecode {0} exceeds the maximum allowed length of {1}
Java.EntityMetadata.Validation.ReservedFieldName = Attempt to use reserved fieldname {0}
Java.EntityMetadata.Validation.DuplicateTag = Duplicate tag {0} in tags.lst file
Java.EntityMetadata.Validation.IncorrectOverrideType = Attempt to apply override of type {0} to a field of type {1}
Java.EntityMetadata.Validation.DatatypeRedefined = Datatype {0} has already been defined at {1}:{2}
Java.EntityMetadata.Validation.EntityDuplicate = Duplicate definition of entity {0} declared at {1}:{2}
Java.EntityMetadata.Validation.DelegateDuplicate = Duplicate definition of delegate {0} declared at {1}:{2}
Java.EntityMetadata.Validation.TypelistDuplicate = Duplicate definition of typelist {0} declared at {1}:{2}
Java.EntityMetadata.Validation.IllegalFileExtension = Illegal extension '{0}' of file {1} for element of type {2}
Java.EntityMetadata.Validation.IllegalFileName = Name mismatch between the file {0} and the {1} {2}
Java.EntityMetadata.Validation.OverrideNonExistentField = Attempt to override non-existent field {0}
Java.EntityMetadata.Validation.OverrideNonExistentEntity = Extension refers to a non-existent extendable entity {0}
Java.EntityMetadata.Validation.ColumnMissingRequiredParam = The column {0} does not have a column parameter {1} required for {2} data type
Java.EntityMetadata.Validation.XMLSchemaValidation = {0}
Java.EntityMetadata.Validation.TypelistExtensionTypecodeCategoryNonExistent = Extension typecode {0} category refers to a typecode {1} that does not exist
Java.EntityMetadata.Validation.TypelistExtensionFilterCategoryNonExistent = Extension filter {0} category refers to a typecode {1} that does not exist
Java.EntityMetadata.Validation.TypelistExtensionIncludeCodeNonExistent = Extension filter {0} include refers to a typecode {1} that does not exist
Java.EntityMetadata.Validation.TypelistExtensionExcludeCodeNonExistent = Extension filter {0} exclude refers to a typecode {1} that does not exist
Java.EntityMetadata.Validation.OverrideFieldMoreThanOnce = Attempt to override field {0} more than once. Previous location {1}:{2}
Java.EntityMetadata.Validation.ExtensionsHaveDifferentImplClass = An interface {0} has different impls in extensions. First use is at {1}:{2}
Java.EntityMetadata.Validation.ColumnHasDifferentParams = Column name {0} is defined on another subtype at {1}:{2} but has different column params
Java.EntityMetadata.Validation.ColumnOverrideHasIncompatibleType = Column override of {0} has datatype {1} that is not compatible with the base model datatype {2}
Java.EntityMetadata.Validation.CycleInHierarchy = Cycle detected in entity hierarchy. {0}